#!/usr/bin/env bash

set -e +o pipefail

ci=""
app=""
branch=""
build=""
job=""
org=""
repo=""
sha=""
slug=""

host="api.featurepeek.com"
image=""
registry_image_path=""
registry=""
tag=""
env_var=""
env_vars=""

res=""

# https://stackoverflow.com/questions/5014632/how-can-i-parse-a-yaml-file-from-a-linux-shell-script
function parse_yaml {
  local prefix=$2
  local s='[[:space:]]*' w='[a-zA-Z0-9_-]*' fs=$(echo @|tr @ '\034')
  sed -ne "s|^\($s\):|\1|" \
    -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
    -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
  awk -F$fs '{
    indent = length($1)/2;
    vname[indent] = $2;
    for (i in vname) {
      if (i > indent) {
        delete vname[i]
      }
    }
    if (length($3) > 0) {
      vn="peek_"; for (i=0; i<indent; i++) {
        gsub(/-/, "_", vname[i]);
        vn=(vn)(vname[i])("_")
      }
      gsub(/^[ \t]+/, "", $3);
      gsub(/[ \t]+$/, "", $3);
      printf("%s%s%s=\"%s\"\n", "'$prefix'", vn, $2, $3);
    }
  }'
}

# CLI args
if [ $# != 0 ];
then
  while getopts "a:de:i:p:r:t:" o
  do
    case "$o" in
      "a")
        app="$OPTARG"
        ;;
      "d")
        host="api.dev.featurepeek.com"
        echo "Pinging dev"
        ;;
      "e")
        echo $OPTARG
        env_var+="$OPTARG||"
        ;;
      "i")
        image="$OPTARG"
        ;;
      "p")
        registry_image_path="$OPTARG"
        ;;
      "r")
        registry="$OPTARG"
        ;;
      "t")
        tag="$OPTARG"
        ;;
    esac
  done
fi

env_vars=$(echo $env_var | sed -e 's/||$//')

# being CI system detection
if [ "$JENKINS_URL" != "" ] || [ "$JENKINS_HOME" != "" ];
then
  echo -e "Jenkins CI detected."
  # https://wiki.jenkins-ci.org/display/JENKINS/Building+a+software+project
  # https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin#GitHubpullrequestbuilderplugin-EnvironmentVariables
  ci="jenkins"
  build="$BUILD_NUMBER"
  
  if [ "$ghprbSourceBranch" != "" ];
  then
    branch="$ghprbSourceBranch"
  elif [ "$GIT_BRANCH" != "" ];
  then
    branch="$GIT_BRANCH"
  elif [ "$CHANGE_BRANCH" != "" ];
  then
    branch="$CHANGE_BRANCH"
  elif [ "$BRANCH_NAME" != "" ];
  then
    branch="$BRANCH_NAME"
  fi

  if [ "$ghprbActualCommit" != "" ];
  then
    sha="$ghprbActualCommit"
  elif [ "$GIT_COMMIT" != "" ];
  then
    sha="$GIT_COMMIT"
  fi
elif [ "$CI" = "true" ] && [ "$TRAVIS" = "true" ] && [ "$SHIPPABLE" != "true" ];
then
  echo -e "Travis CI detected."
  # https://docs.travis-ci.com/user/environment-variables/
  ci="travis"
  branch="$TRAVIS_PULL_REQUEST_BRANCH"
  build="$TRAVIS_JOB_NUMBER"
  job="$TRAVIS_JOB_ID"
  sha="$TRAVIS_PULL_REQUEST_SHA"
  slug="$TRAVIS_REPO_SLUG"
elif [ "$DOCKER_REPO" != "" ];
then
  echo -e "DockerHub detected."
  # https://docs.docker.com/docker-cloud/builds/advanced/
  ci="docker"
  branch="$SOURCE_BRANCH"
  sha="$SOURCE_COMMIT"
  slug="$DOCKER_REPO"
elif [ "$CI" = "true" ] && [ "$CI_NAME" = "codeship" ];
then
  echo -e "Codeship CI detected."
  # https://www.codeship.io/documentation/continuous-integration/set-environment-variables/
  ci="codeship"
  branch="$CI_BRANCH"
  build="$CI_BUILD_NUMBER"
  sha="$CI_COMMIT_ID"
elif [ "$CI" = "true" ] && [ "$CIRCLECI" = "true" ];
then
  echo -e "CircleCI detected."
  # https://circleci.com/docs/environment-variables
  ci="circleci"
  branch="$CIRCLE_BRANCH"
  build="$CIRCLE_BUILD_NUM"
  job="$CIRCLE_NODE_INDEX"
  sha="$CIRCLE_SHA1"
  if [ "$CIRCLE_PROJECT_REPONAME" != "" ];
  then
    slug="$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME"
  else
    # git@github.com:owner/repo.git
    slug="${CIRCLE_REPOSITORY_URL##*:}"
    # owner/repo.git
    slug="${slug%%.git}"
  fi
elif [ "$CIRRUS_CI" != "" ];
then
  echo -e "Cirrus CI detected."
  # https://cirrus-ci.org/guide/writing-tasks/#environment-variables
  ci="cirrusci"
  branch="$CIRRUS_BRANCH"
  sha="$CIRRUS_CHANGE_IN_REPO"
  slug="$CIRRUS_REPO_FULL_NAME"
elif [ "$TEAMCITY_VERSION" != "" ];
then
  echo -e "TeamCity CI detected."
  # https://confluence.jetbrains.com/display/TCD10/Predefined+Build+Parameters
  ci="teamcity"
  branch="$BRANCH_NAME"
  sha="$BUILD_VCS_NUMBER"
elif [ "$WERCKER_MAIN_PIPELINE_STARTED" != "" ];
then
  echo -e "Wercker CI detected."
  # https://devcenter.wercker.com/administration/environment-variables/available-env-vars/
  ci="wercker"
  branch="$WERCKER_GIT_BRANCH"
  sha="$WERCKER_GIT_COMMIT"
  build="$WERCKER_MAIN_PIPELINE_STARTED"
  slug="$WERCKER_GIT_OWNER/$WERCKER_GIT_REPOSITORY"
elif [ "$CI" = "true" ] && [ "$SEMAPHORE" = "true" ];
then
  echo -e "Semaphore CI detected."
  # https://semaphoreapp.com/docs/available-environment-variables.html
  ci="semaphore"
  branch="$BRANCH_NAME"
  build="$SEMAPHORE_BUILD_NUMBER"
  job="$SEMAPHORE_CURRENT_THREAD"
  sha="$REVISION"
  slug="$SEMAPHORE_REPO_SLUG"
elif [ "$CI" = "true" ] && [ "$BUILDKITE" = "true" ];
then
  echo -e "Buildkite CI detected."
  # https://buildkite.com/docs/guides/environment-variables
  ci="buildkite"
  branch="$BUILDKITE_BRANCH"
  build="$BUILDKITE_BUILD_NUMBER"
  job="$BUILDKITE_JOB_ID"
  sha="$BUILDKITE_COMMIT"
  slug="$BUILDKITE_PROJECT_SLUG"
elif [ "$CI" = "drone" ] || [ "$DRONE" = "true" ];
then
  echo -e "Drone CI detected."
  # http://docs.drone.io/env.html
  # drone commits are not full shas
  ci="drone.io"
  branch="$DRONE_SOURCE_BRANCH"
  build="$DRONE_BUILD_NUMBER"
  job="$DRONE_JOB_NUMBER"
elif [ "$HEROKU_TEST_RUN_BRANCH" != "" ];
then
  echo -e "Heroku CI detected."
  # https://devcenter.heroku.com/articles/heroku-ci#environment-variables
  ci="heroku"
  branch="$HEROKU_TEST_RUN_BRANCH"
  build="$HEROKU_TEST_RUN_ID"
  sha="$HEROKU_TEST_RUN_COMMIT_VERSION"
  slug="$GITHUB_SLUG"
elif [ "$DEPLOY_PRIME_URL" != "" ];
then
  echo -e "Netlify CI detected."
  # https://www.netlify.com/docs/continuous-deployment/#environment-variables
  ci="netlify"
  branch="$HEAD"
  build="$REVIEW_ID"
  sha="$COMMIT_REF"
  slug=$(echo "$REPOSITORY_URL" | cut -d / -f 4,5)
elif [ "$CODEBUILD_BUILD_ID" != "" ];
then
  echo -e "AWS CodeBuild detected."
  # https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-env-vars.html
  ci="aws_codebuild"
  branch=$(echo "$CODEBUILD_WEBHOOK_HEAD_REF" | cut -d "/" -f 3)
  build="$CODEBUILD_BUILD_ID"
  job="$CODEBUILD_SOURCE_VERSION"
  sha="$CODEBUILD_RESOLVED_SOURCE_VERSION"
  # slug=$(echo "$CODEBUILD_SOURCE_REPO_URL" | cut -d / -f 4,5)
elif [ "$SYSTEM_TEAMFOUNDATIONSERVERURI" != "" ];
then
  echo -e "Azure Pipelines detected."
  # https://docs.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=vsts
  ci="azure_pipelines"
  branch="$SYSTEM_PULLREQUEST_SOURCEBRANCH"
  build="$BUILD_BUILDNUMBER"
  job="$BUILD_BUILDID"
  sha=$(git rev-parse HEAD^2)
elif [ "$GITHUB_ACTION" != "" ] || [ "$GITHUB_WORKFLOW" != "" ];
then
  echo -e "GitHub Actions detected."
  # https://help.github.com/en/articles/virtual-environments-for-github-actions#default-environment-variables
  ci="github_actions"
  branch="$GITHUB_REF"
  sha="$GITHUB_SHA"
  slug="$GITHUB_REPOSITORY"
else
  echo -e "CI system not identified."
  exit 0
fi

# catchall for missing values
# find branch from git command
if [ "$branch" = "" ];
then
  branch="$GIT_BRANCH"
elif [ "$branch" = "" ];
then
  branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
  if [ "$branch" = "HEAD" ];
  then
    branch=""
  fi
fi

# find commit from git command
if [ "$sha" = "" ];
then
  # merge commit -> actual commit
  mc=
  if [ -n "$pr" ] && [ "$pr" != false ];
  then
    mc=$(git show --no-patch --format="%P" 2>/dev/null || echo "")
  fi
  if [[ "$mc" =~ ^[a-z0-9]{40}[[:space:]][a-z0-9]{40}$ ]];
  then
    echo -e "    Fixing merge commit SHA"
    sha=$(echo "$mc" | cut -d' ' -f2)
  elif [ "$GIT_COMMIT" != "" ];
  then
    sha="$GIT_COMMIT"
  elif [ "$sha" = "" ];
  then
    sha=$(git log -1 --format="%H" 2>/dev/null || echo "")
  fi
fi

# find slug from git command
if [ "$slug" = "" ];
then
  if [ "$remote_addr" = "" ];
  then
    remote_addr=$(git config --get remote.origin.url || echo "")
  fi
  if [ "$remote_addr" != "" ];
  then
    if echo "$remote_addr" | grep -q "//"; then
      # https
      slug=$(echo "$remote_addr" | cut -d / -f 4,5 | sed -e 's/\.git$//')
    else
      # ssh
      slug=$(echo "$remote_addr" | cut -d : -f 2 | sed -e 's/\.git$//')
    fi
  fi
  if [ "$slug" = "/" ];
  then
    slug=""
  fi
fi

# if tag is not supplied, set it to the sha
if [ "$tag" = "" ];
then
  tag="$sha"
fi

# get org and repo from slug
org=$(echo "$slug" | cut -d / -f 1)
repo=$(echo "$slug" | cut -d / -f 2)

# if -a is not passed, default to first app definition in peek.yml file
if [ "$app" = "" ];
then
  app=$(cat peek.y*l | grep -E :$ | head -n 1 | sed 's/:$//')
  # otherwise fallback to 'main'
  if [ "$app" = "" ] || [ "$app" = "services" ];
  then
    app="main"
  fi
fi

# parse peek.yml config file
eval $(parse_yaml peek.y*l)
if [ "$peek_version" != "" ];
then
  safeapp=$(echo $app | sed -e 's/-/_/g')
  static_build_path=$(eval "echo \$peek_${safeapp}_path" | xargs | sed 's/^\///')
else
  static_build_path=$(cat peek.y*l | grep staticBuildPath | tail -n 1 | cut -d : -f 2 | xargs | sed 's/^\///')
fi

# URL endpoint
url="https://$host/api/v1/peek"


echo -e ""
echo -e "app:     $app"
echo -e "branch:  $branch"
echo -e "build:   $build"
echo -e "ci:      $ci"
echo -e "job:     $job"
echo -e "org:     $org"
echo -e "repo:    $repo"
echo -e "sha:     $sha"
echo -e ""

if [ "$static_build_path" != "" ];
then
  echo -e "Static build detected."

  # heroku ci changes file permissions, set them back
  if [ "$ci" = "heroku" ];
  then
    cp -R $static_build_path "$static_build_path-copy"
    chmod -R 755 "$static_build_path-copy"
    static_build_path="$static_build_path-copy"
  fi

  # zip up static assets
  cd $static_build_path

  ext=""
  has_zip=$(echo -e `which zip`)
  if [ "$has_zip" != "" ];
  then
    ext="zip"
    zip -r ../artifacts.zip .
  else
    echo -e "zip not found, falling back to tar"
    ext="tar.gz"
    tar -czf ../artifacts.tar.gz .
  fi

  cd ..
fi

# try to contact FeaturePeek API 3 times
i="0"
while [ $i -lt 3 ]
do
  i=$[$i+1]

if [ "$static_build_path" != "" ];
then
  # form/multipart for zipped static assets
  res=$(curl -i \
    -F "artifacts=@artifacts.$ext" \
    -F "app=$app" \
    -F "branch=$branch" \
    -F "build=$build" \
    -F "job=$job" \
    -F "org=$org" \
    -F "repo=$repo" \
    -F "ci=$ci" \
    -F "sha=$sha" \
    $url)
elif [ "$AWS_ACCOUNT_ID" != "" ];
then
  echo -e "Amazon ECR detected."

  # defaults
  region=""
  if [ "$AWS_DEFAULT_REGION" != "" ];
  then
    region="$AWS_DEFAULT_REGION"
  elif [ "$AWS_REGION" != "" ];
  then
    region="$AWS_REGION"
  fi

  if [ "$registry_image_path" != "" ];
  then
    echo -e "Registry image path (-p) passed in directly."
  elif [ "$registry" != "" ] && [ "$image" != "" ];
  then
    echo -e "Registry (-r) and image (-i) passed in directly."
    registry_image_path="$registry/$image:$tag"
  else
    echo -e "Registry image path composed from environment variables."
    registry_image_path="$AWS_ACCOUNT_ID.dkr.ecr.$region.amazonaws.com/$AWS_RESOURCE_NAME_PREFIX:$tag"
  fi
  echo -e "Registry image path: $registry_image_path"

  res=$(curl -i $url \
    -X POST \
    -H "Accept: application/json" \
    -H "Content-Type: application/json" \
    -d @<(cat <<EOF
{
  "registry_image_path": "$registry_image_path",
  "aws_account": "$AWS_ACCOUNT_ID",
  "aws_access_key": "$AWS_ACCESS_KEY_ID",
  "aws_secret_access_key": "$AWS_SECRET_ACCESS_KEY",
  "aws_region": "$region",
  "app": "$app", "branch": "$branch", "org": "$org", "repo": "$repo", "ci": "$ci", "sha": "$sha",
  "env_vars": "$env_vars"
}
EOF
))
elif [ "$GOOGLE_PROJECT_ID" != "" ];
then
  echo -e "Google Cloud Registry detected."

  # defaults
  if [ "$registry" = "" ];
  then
    registry="gcr.io"
  fi

  service_key=""
  if [ "$GCLOUD_SERVICE_KEY" != "" ];
  then
    service_key="$GCLOUD_SERVICE_KEY"
  elif [ "$GOOGLE_APPLICATION_CREDENTIALS" != "" ];
  then
    service_key="$GOOGLE_APPLICATION_CREDENTIALS"
  else
    echo "GCloud Service Key not found. Please ensure you have all the required environment variables."
    exit 0
  fi

  if [ "$registry_image_path" != "" ];
  then
    echo -e "Registry image path (-p) passed in directly."
  else
    registry_image_path="$registry/$GOOGLE_PROJECT_ID/$image:$tag"
  fi
  echo -e "Registry image path: $registry_image_path"
  
  res=$(curl -i $url \
    -X POST \
    -H "Accept: application/json" \
    -H "Content-Type: application/json" \
    -d @<(cat <<EOF
{
  "registry_image_path": "$registry_image_path",
  "gcloud_service_key": $service_key,
  "google_compute_zone": "$GOOGLE_COMPUTE_ZONE",
  "google_project_id": "$GOOGLE_PROJECT_ID",
  "app": "$app", "branch": "$branch", "org": "$org", "repo": "$repo", "ci": "$ci", "sha": "$sha",
  "env_vars": "$env_vars"
}
EOF
))
elif [ "$DOCKER_LOGIN" != "" ] || [ "$DOCKER_USERNAME" != "" ];
then
  echo -e "DockerHub detected."

  # defaults
  if [ "$registry" = "" ];
  then
    registry="docker.io"
  fi

  docker_username=""
  if [ "$DOCKER_LOGIN" != "" ];
  then
    docker_username="$DOCKER_LOGIN"
  elif [ "$DOCKER_USERNAME" != "" ];
  then
    docker_username="$DOCKER_USERNAME"
  else
    echo "Docker username not found. Please ensure you have all the required environment variables."
    exit 0
  fi

  if [ "$registry_image_path" != "" ];
  then
    echo -e "Registry image path (-p) passed in directly."
  else
    echo -e "Image (-i) passed in directly."
    registry_image_path="$registry/$image:$tag"
  fi
  echo -e "Registry image path: $registry_image_path"
  
  res=$(curl -i $url \
    -X POST \
    -H "Accept: application/json" \
    -H "Content-Type: application/json" \
    -d @<(cat <<EOF
{
  "registry_image_path": "$(echo "$registry_image_path" | cut -d / -f 2,3)",
  "dockerhub_username": "$docker_username",
  "dockerhub_password": "$DOCKER_PASSWORD",
  "dockerhub_registry": "$(echo "$registry_image_path" | cut -d / -f 1)",
  "app": "$app", "branch": "$branch", "org": "$org", "repo": "$repo", "ci": "$ci", "sha": "$sha",
  "env_vars": "$env_vars"
}
EOF
))
else
  echo -e ""
  echo -e "Container registry not identified."
  exit 0
fi

  # still within the while loop here
  if [ "$res" != "" ];
  then
    status=$(echo "$res" | head -1 | cut -d' ' -f2)
    echo -e ""
    echo -e "$res"
    # if status > 200...
    if [ "${status:0:1}" != "1" ] && [ "${status:0:1}" != "2" ];
    then
      echo -e "Trying again in 15s..."
      sleep 15
    else
      exit 0
    fi
  else
    echo -e "Empty response. Trying again in 15s..."
    sleep 15
  fi

# end while loop
done


echo -e "Failed to reach FeaturePeek API."
exit 0
